# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_interfaces_ietf_routing__routing_state_routing_instance_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network layer interfaces belonging to the routing
instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing_state/routing_instance/interfaces/interface (if:interface-state-ref)

    YANG Description: Each entry is a reference to the name of a configured
network layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing_state/routing_instance/interfaces/interface (if:interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-state-ref""",
          'defined-type': "if:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_routing_protocol_ietf_routing__routing_state_routing_instance_routing_protocols_routing_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/routing-protocols/routing-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of a routing protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the type 'direct'. Other
instances MAY be created by configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name',)

  _yang_name = 'routing-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'routing-protocols', u'routing-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol/type (identityref)

    YANG Description: Type of the routing protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the routing protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol/name (string)

    YANG Description: The name of the routing protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the routing protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ])


class yc_routing_protocols_ietf_routing__routing_state_routing_instance_routing_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/routing-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the list of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_protocol',)

  _yang_name = 'routing-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_protocol = YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_state_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'routing-protocols']

  def _get_routing_protocol(self):
    """
    Getter method for routing_protocol, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol (list)

    YANG Description: State data of a routing protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the type 'direct'. Other
instances MAY be created by configuration.
    """
    return self.__routing_protocol
      
  def _set_routing_protocol(self, v, load=False):
    """
    Setter method for routing_protocol, mapped from YANG variable /routing_state/routing_instance/routing_protocols/routing_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocol() directly.

    YANG Description: State data of a routing protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the type 'direct'. Other
instances MAY be created by configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_state_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_state_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__routing_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocol(self):
    self.__routing_protocol = YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_state_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  routing_protocol = __builtin__.property(_get_routing_protocol)


  _pyangbind_elements = OrderedDict([('routing_protocol', routing_protocol), ])


class yc_next_hop_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__next_hop_address','__special_next_hop',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__next_hop_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="next-hop-address", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'ribs', u'rib', u'routes', u'route', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/outgoing_interface (string)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/outgoing_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_next_hop_address(self):
    """
    Getter method for next_hop_address, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/next_hop_address (string)

    YANG Description: IP address.
    """
    return self.__next_hop_address
      
  def _set_next_hop_address(self, v, load=False):
    """
    Setter method for next_hop_address, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/next_hop_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_address() directly.

    YANG Description: IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="next-hop-address", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="next-hop-address", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__next_hop_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_address(self):
    self.__next_hop_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="next-hop-address", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Special next-hop options.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Special next-hop options.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  next_hop_address = __builtin__.property(_get_next_hop_address)
  special_next_hop = __builtin__.property(_get_special_next_hop)

  __choices__ = {u'next-hop-options': {u'simple-next-hop': [u'outgoing_interface', u'next_hop_address'], u'special-next-hop': [u'special_next_hop']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('next_hop_address', next_hop_address), ('special_next_hop', special_next_hop), ])


class yc_route_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry. This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__destination_prefix','__metric','__next_hop','__source_protocol','__active','__last_updated','__update_source',)

  _yang_name = 'route'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__update_source = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='uint32', is_config=False)
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__destination_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'ribs', u'rib', u'routes', u'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix. A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix. A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_destination_prefix(self):
    """
    Getter method for destination_prefix, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/destination_prefix (string)

    YANG Description: Destination IP address with prefix
    """
    return self.__destination_prefix
      
  def _set_destination_prefix(self, v, load=False):
    """
    Setter method for destination_prefix, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/destination_prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_prefix() directly.

    YANG Description: Destination IP address with prefix
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="destination-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__destination_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_prefix(self):
    self.__destination_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="destination-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_metric(self):
    """
    Getter method for metric, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/metric (uint32)

    YANG Description: Route metric.
    """
    return self.__metric
      
  def _set_metric(self, v, load=False):
    """
    Setter method for metric, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/metric (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: Route metric.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='uint32', is_config=False)""",
        })

    self.__metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric(self):
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='uint32', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route. If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route. If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)


  def _get_update_source(self):
    """
    Getter method for update_source, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/update_source (string)

    YANG Description: Update source for the route.
    """
    return self.__update_source
      
  def _set_update_source(self, v, load=False):
    """
    Setter method for update_source, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route/update_source (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_update_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_update_source() directly.

    YANG Description: Update source for the route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """update_source must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__update_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_update_source(self):
    self.__update_source = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="update-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  destination_prefix = __builtin__.property(_get_destination_prefix)
  metric = __builtin__.property(_get_metric)
  next_hop = __builtin__.property(_get_next_hop)
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)
  update_source = __builtin__.property(_get_update_source)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('destination_prefix', destination_prefix), ('metric', metric), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ('update_source', update_source), ])


class yc_routes_ietf_routing__routing_state_routing_instance_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("destination_prefix",yc_route_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-prefix', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'ribs', u'rib', u'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry. This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry. This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("destination_prefix",yc_route_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-prefix', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("destination_prefix",yc_route_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-prefix', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("destination_prefix",yc_route_ietf_routing__routing_state_routing_instance_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-prefix', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route)


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_rib_ietf_routing__routing_state_routing_instance_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

For each routing instance, an implementation SHOULD
provide one system-controlled default RIB for each
supported address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_routing_instance_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/routing_instance/ribs/rib/name (string)

    YANG Description: The name of the RIB.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/routing_instance/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing_state/routing_instance/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing_state/routing_instance/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing_state/routing_instance/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

A default RIB always receives direct routes. By
default it also receives routes from all routing
protocols.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing_state/routing_instance/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

A default RIB always receives direct routes. By
default it also receives routes from all routing
protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing_state/routing_instance/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_state_routing_instance_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_state_routing_instance_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_routing_instance_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  address_family = __builtin__.property(_get_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ])


class yc_ribs_ietf_routing__routing_state_routing_instance_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing_state/routing_instance/ribs/rib (list)

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

For each routing instance, an implementation SHOULD
provide one system-controlled default RIB for each
supported address family.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing_state/routing_instance/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

For each routing instance, an implementation SHOULD
provide one system-controlled default RIB for each
supported address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_state_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  rib = __builtin__.property(_get_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_instance_ietf_routing__routing_state_routing_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/routing-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each list entry is a container for state data of a routing
instance.

An implementation MUST support routing instance(s) of the
type 'rt:default-routing-instance', and MAY support other
types. An implementation MAY restrict the number of routing
instances of each supported type.

An implementation SHOULD create at least one
system-controlled instance, and MAY allow the clients to
create user-controlled routing instances in
configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__router_id','__interfaces','__routing_protocols','__ribs',)

  _yang_name = 'routing-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_state_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'routing-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/routing_instance/name (string)

    YANG Description: The name of the routing instance.

For system-controlled instances the name is persistent,
i.e., it SHOULD NOT change across reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/routing_instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the routing instance.

For system-controlled instances the name is persistent,
i.e., it SHOULD NOT change across reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/routing_instance/type (identityref)

    YANG Description: The routing instance type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/routing_instance/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The routing instance type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing_state/routing_instance/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing_state/routing_instance/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing_state/routing_instance/interfaces (container)

    YANG Description: Network layer interfaces belonging to the routing
instance.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing_state/routing_instance/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network layer interfaces belonging to the routing
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_state_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_routing_protocols(self):
    """
    Getter method for routing_protocols, mapped from YANG variable /routing_state/routing_instance/routing_protocols (container)

    YANG Description: Container for the list of routing protocol instances.
    """
    return self.__routing_protocols
      
  def _set_routing_protocols(self, v, load=False):
    """
    Setter method for routing_protocols, mapped from YANG variable /routing_state/routing_instance/routing_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocols() directly.

    YANG Description: Container for the list of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_protocols_ietf_routing__routing_state_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_state_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routing_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocols(self):
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_state_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing_state/routing_instance/ribs (container)

    YANG Description: Container for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing_state/routing_instance/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Container for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_state_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_state_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  router_id = __builtin__.property(_get_router_id)
  interfaces = __builtin__.property(_get_interfaces)
  routing_protocols = __builtin__.property(_get_routing_protocols)
  ribs = __builtin__.property(_get_ribs)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('router_id', router_id), ('interfaces', interfaces), ('routing_protocols', routing_protocols), ('ribs', ribs), ])


class yc_routing_state_ietf_routing__routing_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_instance',)

  _yang_name = 'routing-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_instance = YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_state_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state']

  def _get_routing_instance(self):
    """
    Getter method for routing_instance, mapped from YANG variable /routing_state/routing_instance (list)

    YANG Description: Each list entry is a container for state data of a routing
instance.

An implementation MUST support routing instance(s) of the
type 'rt:default-routing-instance', and MAY support other
types. An implementation MAY restrict the number of routing
instances of each supported type.

An implementation SHOULD create at least one
system-controlled instance, and MAY allow the clients to
create user-controlled routing instances in
configuration.
    """
    return self.__routing_instance
      
  def _set_routing_instance(self, v, load=False):
    """
    Setter method for routing_instance, mapped from YANG variable /routing_state/routing_instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_instance() directly.

    YANG Description: Each list entry is a container for state data of a routing
instance.

An implementation MUST support routing instance(s) of the
type 'rt:default-routing-instance', and MAY support other
types. An implementation MAY restrict the number of routing
instances of each supported type.

An implementation SHOULD create at least one
system-controlled instance, and MAY allow the clients to
create user-controlled routing instances in
configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_routing_instance_ietf_routing__routing_state_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_state_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__routing_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_instance(self):
    self.__routing_instance = YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_state_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  routing_instance = __builtin__.property(_get_routing_instance)


  _pyangbind_elements = OrderedDict([('routing_instance', routing_instance), ])


class yc_interfaces_ietf_routing__routing_routing_instance_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Assignment of the routing instance's interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/routing_instance/interfaces/interface (if:interface-ref)

    YANG Description: The name of a configured network layer interface to be
assigned to the routing-instance.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/routing_instance/interfaces/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The name of a configured network layer interface to be
assigned to the routing-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_routing_protocol_ietf_routing__routing_routing_instance_routing_protocols_routing_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance/routing-protocols/routing-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains configuration of a routing protocol
instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description',)

  _yang_name = 'routing-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance', u'routing-protocols', u'routing-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/type (identityref)

    YANG Description: Type of the routing protocol - an identity derived
from the 'routing-protocol' base identity.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the routing protocol - an identity derived
from the 'routing-protocol' base identity.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/name (string)

    YANG Description: An arbitrary name of the routing protocol instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the routing protocol instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/description (string)

    YANG Description: Textual description of the routing protocol
instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the routing protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ])


class yc_routing_protocols_ietf_routing__routing_routing_instance_routing_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance/routing-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_protocol',)

  _yang_name = 'routing-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_protocol = YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance', u'routing-protocols']

  def _get_routing_protocol(self):
    """
    Getter method for routing_protocol, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol (list)

    YANG Description: Each entry contains configuration of a routing protocol
instance.
    """
    return self.__routing_protocol
      
  def _set_routing_protocol(self, v, load=False):
    """
    Setter method for routing_protocol, mapped from YANG variable /routing/routing_instance/routing_protocols/routing_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocol() directly.

    YANG Description: Each entry contains configuration of a routing protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__routing_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocol(self):
    self.__routing_protocol = YANGDynClass(base=YANGListType("type name",yc_routing_protocol_ietf_routing__routing_routing_instance_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  routing_protocol = __builtin__.property(_get_routing_protocol, _set_routing_protocol)


  _pyangbind_elements = OrderedDict([('routing_protocol', routing_protocol), ])


class yc_rib_ietf_routing__routing_routing_instance_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing-state/routing-instance/ribs/rib are
used for configuring parameters of that entry. Other
entries define additional user-controlled RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__description',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/routing_instance/ribs/rib/name (string)

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding
entry in state data.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/routing_instance/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding
entry in state data.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing/routing_instance/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing/routing_instance/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/routing_instance/ribs/rib/description (string)

    YANG Description: Textual description of the RIB.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/routing_instance/ribs/rib/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('description', description), ])


class yc_ribs_ietf_routing__routing_routing_instance_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/routing_instance/ribs/rib (list)

    YANG Description: Each entry contains configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing-state/routing-instance/ribs/rib are
used for configuring parameters of that entry. Other
entries define additional user-controlled RIBs.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/routing_instance/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry contains configuration for a RIB identified
by the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing-state/routing-instance/ribs/rib are
used for configuring parameters of that entry. Other
entries define additional user-controlled RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_routing_instance_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  rib = __builtin__.property(_get_rib, _set_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_instance_ietf_routing__routing_routing_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/routing-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of a routing instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__enabled','__router_id','__description','__interfaces','__routing_protocols','__ribs',)

  _yang_name = 'routing-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=True)
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), default=six.text_type("rt:default-routing-instance"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'routing-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/routing_instance/name (string)

    YANG Description: The name of the routing instance.

For system-controlled entries, the value of this leaf must
be the same as the name of the corresponding entry in
state data.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/routing_instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the routing instance.

For system-controlled entries, the value of this leaf must
be the same as the name of the corresponding entry in
state data.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/routing_instance/type (identityref)

    YANG Description: The type of the routing instance.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/routing_instance/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the routing instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), default=six.text_type("rt:default-routing-instance"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), default=six.text_type("rt:default-routing-instance"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:default-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:vrf-routing-instance': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), default=six.text_type("rt:default-routing-instance"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/routing_instance/enabled (boolean)

    YANG Description: Enable/disable the routing instance.

If this parameter is false, the parent routing instance is
disabled and does not appear in state data, despite any
other configuration that might be present.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/routing_instance/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable/disable the routing instance.

If this parameter is false, the parent routing instance is
disabled and does not appear in state data, despite any
other configuration that might be present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=True)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing/routing_instance/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing/routing_instance/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/routing_instance/description (string)

    YANG Description: Textual description of the routing instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/routing_instance/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the routing instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/routing_instance/interfaces (container)

    YANG Description: Assignment of the routing instance's interfaces.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/routing_instance/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Assignment of the routing instance's interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_routing_instance_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_protocols(self):
    """
    Getter method for routing_protocols, mapped from YANG variable /routing/routing_instance/routing_protocols (container)

    YANG Description: Configuration of routing protocol instances.
    """
    return self.__routing_protocols
      
  def _set_routing_protocols(self, v, load=False):
    """
    Setter method for routing_protocols, mapped from YANG variable /routing/routing_instance/routing_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocols() directly.

    YANG Description: Configuration of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_protocols_ietf_routing__routing_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocols(self):
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_routing__routing_routing_instance_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing/routing_instance/ribs (container)

    YANG Description: Configuration of RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing/routing_instance/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Configuration of RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_routing_instance_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  router_id = __builtin__.property(_get_router_id, _set_router_id)
  description = __builtin__.property(_get_description, _set_description)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  routing_protocols = __builtin__.property(_get_routing_protocols, _set_routing_protocols)
  ribs = __builtin__.property(_get_ribs, _set_ribs)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('enabled', enabled), ('router_id', router_id), ('description', description), ('interfaces', interfaces), ('routing_protocols', routing_protocols), ('ribs', ribs), ])


class yc_routing_ietf_routing__routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_instance',)

  _yang_name = 'routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_instance = YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing']

  def _get_routing_instance(self):
    """
    Getter method for routing_instance, mapped from YANG variable /routing/routing_instance (list)

    YANG Description: Configuration of a routing instance.
    """
    return self.__routing_instance
      
  def _set_routing_instance(self, v, load=False):
    """
    Setter method for routing_instance, mapped from YANG variable /routing/routing_instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_instance() directly.

    YANG Description: Configuration of a routing instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_routing_instance_ietf_routing__routing_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__routing_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_instance(self):
    self.__routing_instance = YANGDynClass(base=YANGListType("name",yc_routing_instance_ietf_routing__routing_routing_instance, yang_name="routing-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="routing-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  routing_instance = __builtin__.property(_get_routing_instance, _set_routing_instance)


  _pyangbind_elements = OrderedDict([('routing_instance', routing_instance), ])


class ietf_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /ietf-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines essential components for the management
of a routing subsystem.

Copyright (c) 2014 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
'OPTIONAL' in the module text are to be interpreted as described
in RFC 2119 (http://tools.ietf.org/html/rfc2119).

This version of this YANG module is part of RFC XXXX
(http://tools.ietf.org/html/rfcXXXX); see the RFC itself for
full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_state','__routing',)

  _yang_name = 'ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /routing_state (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /routing_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /routing (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  routing_state = __builtin__.property(_get_routing_state, _set_routing_state)
  routing = __builtin__.property(_get_routing, _set_routing)


  _pyangbind_elements = OrderedDict([('routing_state', routing_state), ('routing', routing), ])


