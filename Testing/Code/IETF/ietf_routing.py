# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_interfaces_ietf_routing__routing_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains a control-plane protocol instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description',)

  _yang_name = 'control-plane-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ])


class yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for control-plane protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol, _set_control_plane_protocol)


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list)

  __choices__ = {u'next-hop-options': {u'simple-next-hop': [u'outgoing_interface'], u'next-hop-list': [u'next_hop_list'], u'special-next-hop': [u'special_next_hop']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop)
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route)


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_rib_ietf_routing__routing_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__description',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/ribs/rib/name (string)

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/ribs/rib/description (string)

    YANG Description: Textual description of the RIB.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/ribs/rib/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes, _set_routes)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('description', description), ])


class yc_ribs_ietf_routing__routing_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/ribs/rib (list)

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  rib = __builtin__.property(_get_rib, _set_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_ietf_routing__routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)

    YANG Description: Support for control-plane protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Support for control-plane protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing/ribs (container)

    YANG Description: Support for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Support for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols, _set_control_plane_protocols)
  ribs = __builtin__.property(_get_ribs, _set_ribs)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class yc_interfaces_ietf_routing__routing_state_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-state-ref""",
          'defined-type': "if:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name',)

  _yang_name = 'control-plane-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'control-plane-protocols', u'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ])


class yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the list of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol)


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list)

  __choices__ = {u'next-hop-options': {u'simple-next-hop': [u'outgoing_interface'], u'next-hop-list': [u'next_hop_list'], u'special-next-hop': [u'special_next_hop']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop)
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_state_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route)


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_rib_ietf_routing__routing_state_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)

    YANG Description: The name of the RIB.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  address_family = __builtin__.property(_get_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ])


class yc_ribs_ietf_routing__routing_state_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  rib = __builtin__.property(_get_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_state_ietf_routing__routing_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)

    YANG Description: Container for the list of routing protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Container for the list of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing_state/ribs (container)

    YANG Description: Container for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing_state/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Container for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  interfaces = __builtin__.property(_get_interfaces)
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols)
  ribs = __builtin__.property(_get_ribs)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class ietf_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /ietf-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines essential components for the management
of a routing subsystem. The model fully conforms to the Network
Management Datastore Architecture (NMDA).

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing','__routing_state',)

  _yang_name = 'ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /routing (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /routing_state (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /routing_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  routing = __builtin__.property(_get_routing, _set_routing)
  routing_state = __builtin__.property(_get_routing_state, _set_routing_state)


  _pyangbind_elements = OrderedDict([('routing', routing), ('routing_state', routing_state), ])


