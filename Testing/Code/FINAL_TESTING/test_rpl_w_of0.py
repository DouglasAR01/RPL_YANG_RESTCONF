# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class uis_ofs_of0(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module uis-ofs-of0 - based on the path /uis-ofs-of0. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Objective function Zero for RPL.
  """
  _pyangbind_elements = {}

  

class uis_rpl(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module uis-rpl - based on the path /uis-rpl. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is an a first approach to a fully RPL YANG model
  """
  _pyangbind_elements = {}

  

class yc_interfaces_ietf_routing__routing_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_trickle_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_trickle(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/trickle. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Trickle timer variables and parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__i_min','__i_max','__k','__i','__t','__c',)

  _yang_name = 'trickle'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__c = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="c", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:counter32', is_config=False)
    self.__i = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="i", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)
    self.__k = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)
    self.__i_min = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=True)
    self.__i_max = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)
    self.__t = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'trickle']

  def _get_i_min(self):
    """
    Getter method for i_min, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i_min (uint32)

    YANG Description: The minimum interval size, Imin, is defined in milliseconds (ms).
    """
    return self.__i_min
      
  def _set_i_min(self, v, load=False):
    """
    Setter method for i_min, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i_min (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i_min() directly.

    YANG Description: The minimum interval size, Imin, is defined in milliseconds (ms).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i_min must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=True)""",
        })

    self.__i_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i_min(self):
    self.__i_min = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=True)


  def _get_i_max(self):
    """
    Getter method for i_max, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i_max (uint8)

    YANG Description: The maximum interval size, Imax, is described as a number of
doublings of the minimum interval size (the base-2 log(max/min)).
    """
    return self.__i_max
      
  def _set_i_max(self, v, load=False):
    """
    Setter method for i_max, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i_max (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i_max() directly.

    YANG Description: The maximum interval size, Imax, is described as a number of
doublings of the minimum interval size (the base-2 log(max/min)).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i_max must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)""",
        })

    self.__i_max = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i_max(self):
    self.__i_max = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="i-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)


  def _get_k(self):
    """
    Getter method for k, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/k (uint8)

    YANG Description: The redundancy constant, k, is a natural number (an integer
 greater than zero).
 In RPL, when k has the value of 0, this is to be treated as
 a redundancy constant of infinity
    """
    return self.__k
      
  def _set_k(self, v, load=False):
    """
    Setter method for k, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/k (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_k is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_k() directly.

    YANG Description: The redundancy constant, k, is a natural number (an integer
 greater than zero).
 In RPL, when k has the value of 0, this is to be treated as
 a redundancy constant of infinity
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """k must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)""",
        })

    self.__k = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_k(self):
    self.__k = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=True)


  def _get_i(self):
    """
    Getter method for i, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i (uint32)

    YANG Description: I, the current interval size.
    """
    return self.__i
      
  def _set_i(self, v, load=False):
    """
    Setter method for i, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/i (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i() directly.

    YANG Description: I, the current interval size.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="i", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="i", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)""",
        })

    self.__i = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i(self):
    self.__i = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="i", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)


  def _get_t(self):
    """
    Getter method for t, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/t (uint32)

    YANG Description: t, a time within the current interval.
    """
    return self.__t
      
  def _set_t(self, v, load=False):
    """
    Setter method for t, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/t (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_t is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_t() directly.

    YANG Description: t, a time within the current interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """t must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)""",
        })

    self.__t = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_t(self):
    self.__t = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint32', is_config=False)


  def _get_c(self):
    """
    Getter method for c, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/c (yang:counter32)

    YANG Description: c, a counter.
    """
    return self.__c
      
  def _set_c(self, v, load=False):
    """
    Setter method for c, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle/c (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_c is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_c() directly.

    YANG Description: c, a counter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="c", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """c must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="c", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:counter32', is_config=False)""",
        })

    self.__c = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_c(self):
    self.__c = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="c", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:counter32', is_config=False)

  i_min = __builtin__.property(_get_i_min, _set_i_min)
  i_max = __builtin__.property(_get_i_max, _set_i_max)
  k = __builtin__.property(_get_k, _set_k)
  i = __builtin__.property(_get_i)
  t = __builtin__.property(_get_t)
  c = __builtin__.property(_get_c)


  _pyangbind_elements = OrderedDict([('i_min', i_min), ('i_max', i_max), ('k', k), ('i', i), ('t', t), ('c', c), ])


class yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of RPL interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__oper_status',)

  _yang_name = 'interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='if:interface-ref', is_config=True)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {}, u'up': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'interfaces', u'interface']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface/interface (if:interface-ref)

    YANG Description: Enable RPL on this interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Enable RPL on this interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='if:interface-ref', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface/oper_status (enumeration)

    YANG Description: Operational state.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface/oper_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {}, u'up': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with enumeration""",
          'defined-type': "uis-rpl:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {}, u'up': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='enumeration', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'down': {}, u'up': {}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='enumeration', is_config=False)

  interface = __builtin__.property(_get_interface, _set_interface)
  oper_status = __builtin__.property(_get_oper_status)


  _pyangbind_elements = OrderedDict([('interface', interface), ('oper_status', oper_status), ])


class yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Containing a list of RPL interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("interface",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface (list)

    YANG Description: List of RPL interfaces.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: List of RPL interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("interface",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_variables_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_variables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/objective-functions/objective-function/of0/variables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__step_of_rank','__rank_increase',)

  _yang_name = 'variables'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__step_of_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="step-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)
    self.__rank_increase = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rank-increase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'objective-functions', u'objective-function', u'of0', u'variables']

  def _get_step_of_rank(self):
    """
    Getter method for step_of_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables/step_of_rank (uint16)

    YANG Description: An intermediate computation based on the link properties
with a certain neighbor.
    """
    return self.__step_of_rank
      
  def _set_step_of_rank(self, v, load=False):
    """
    Setter method for step_of_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables/step_of_rank (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step_of_rank is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step_of_rank() directly.

    YANG Description: An intermediate computation based on the link properties
with a certain neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="step-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """step_of_rank must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="step-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)""",
        })

    self.__step_of_rank = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_step_of_rank(self):
    self.__step_of_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="step-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)


  def _get_rank_increase(self):
    """
    Getter method for rank_increase, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables/rank_increase (uint16)

    YANG Description: Delta between the Rank of the preferred parent and self.
    """
    return self.__rank_increase
      
  def _set_rank_increase(self, v, load=False):
    """
    Setter method for rank_increase, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables/rank_increase (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rank_increase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rank_increase() directly.

    YANG Description: Delta between the Rank of the preferred parent and self.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rank-increase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rank_increase must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rank-increase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)""",
        })

    self.__rank_increase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rank_increase(self):
    self.__rank_increase = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="rank-increase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=False)

  step_of_rank = __builtin__.property(_get_step_of_rank)
  rank_increase = __builtin__.property(_get_rank_increase)


  _pyangbind_elements = OrderedDict([('step_of_rank', step_of_rank), ('rank_increase', rank_increase), ])


class yc_parameters_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/objective-functions/objective-function/of0/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stretch_of_rank','__rank_factor',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stretch_of_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="stretch-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)
    self.__rank_factor = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="rank-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'objective-functions', u'objective-function', u'of0', u'parameters']

  def _get_stretch_of_rank(self):
    """
    Getter method for stretch_of_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters/stretch_of_rank (uint16)

    YANG Description: The maximum augmentation to the step_of_rank of a preferred parent
to allow the selection of an additional feasible successor.
If none is configured to the device, then the step_of_rank is not
stretched.
    """
    return self.__stretch_of_rank
      
  def _set_stretch_of_rank(self, v, load=False):
    """
    Setter method for stretch_of_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters/stretch_of_rank (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stretch_of_rank is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stretch_of_rank() directly.

    YANG Description: The maximum augmentation to the step_of_rank of a preferred parent
to allow the selection of an additional feasible successor.
If none is configured to the device, then the step_of_rank is not
stretched.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="stretch-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stretch_of_rank must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="stretch-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)""",
        })

    self.__stretch_of_rank = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stretch_of_rank(self):
    self.__stretch_of_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="stretch-of-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)


  def _get_rank_factor(self):
    """
    Getter method for rank_factor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters/rank_factor (uint16)

    YANG Description: A configurable factor that is used to multiply the effect of the
link properties in the rank_increase computation.
If none is configured, then a rank_factor of 1 is used.
    """
    return self.__rank_factor
      
  def _set_rank_factor(self, v, load=False):
    """
    Setter method for rank_factor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters/rank_factor (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rank_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rank_factor() directly.

    YANG Description: A configurable factor that is used to multiply the effect of the
link properties in the rank_increase computation.
If none is configured, then a rank_factor of 1 is used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="rank-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rank_factor must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="rank-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)""",
        })

    self.__rank_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rank_factor(self):
    self.__rank_factor = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="rank-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='uint16', is_config=True)

  stretch_of_rank = __builtin__.property(_get_stretch_of_rank, _set_stretch_of_rank)
  rank_factor = __builtin__.property(_get_rank_factor, _set_rank_factor)


  _pyangbind_elements = OrderedDict([('stretch_of_rank', stretch_of_rank), ('rank_factor', rank_factor), ])


class yc_of0_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/objective-functions/objective-function/of0. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__variables','__parameters',)

  _yang_name = 'of0'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__variables = YANGDynClass(base=yc_variables_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_variables, is_container='container', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)
    self.__parameters = YANGDynClass(base=yc_parameters_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_parameters, is_container='container', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'objective-functions', u'objective-function', u'of0']

  def _get_variables(self):
    """
    Getter method for variables, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables (container)
    """
    return self.__variables
      
  def _set_variables(self, v, load=False):
    """
    Setter method for variables, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/variables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_variables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_variables() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_variables_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_variables, is_container='container', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """variables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_variables_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_variables, is_container='container', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)""",
        })

    self.__variables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_variables(self):
    self.__variables = YANGDynClass(base=yc_variables_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_variables, is_container='container', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters (container)
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0/parameters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_parameters_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_parameters, is_container='container', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_parameters_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_parameters, is_container='container', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=yc_parameters_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0_parameters, is_container='container', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)

  variables = __builtin__.property(_get_variables, _set_variables)
  parameters = __builtin__.property(_get_parameters, _set_parameters)


  _pyangbind_elements = OrderedDict([('variables', variables), ('parameters', parameters), ])


class yc_objective_function_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/objective-functions/objective-function. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains an objective function instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description','__of0',)

  _yang_name = 'objective-function'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__of0 = YANGDynClass(base=yc_of0_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0, is_container='container', yang_name="of0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}, u'of0:of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'objective-functions', u'objective-function']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/type (identityref)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}, u'of0:of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "uis-rpl:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}, u'of0:of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}, u'of0:of-of0': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-ofs-of0', u'@module': u'uis-ofs-of0'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/name (string)

    YANG Description: An arbitrary name of the objective function instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the objective function instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/description (string)

    YANG Description: Textual description of the objective function instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the objective function instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='string', is_config=True)


  def _get_of0(self):
    """
    Getter method for of0, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0 (container)
    """
    return self.__of0
      
  def _set_of0(self, v, load=False):
    """
    Setter method for of0, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function/of0 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_of0 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_of0() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_of0_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0, is_container='container', yang_name="of0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """of0 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_of0_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0, is_container='container', yang_name="of0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)""",
        })

    self.__of0 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_of0(self):
    self.__of0 = YANGDynClass(base=yc_of0_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function_of0, is_container='container', yang_name="of0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-ofs-of0', defining_module='uis-ofs-of0', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  of0 = __builtin__.property(_get_of0, _set_of0)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ('of0', of0), ])


class yc_objective_functions_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/objective-functions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for objective functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__objective_function',)

  _yang_name = 'objective-functions'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__objective_function = YANGDynClass(base=YANGListType("type name",yc_objective_function_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function, yang_name="objective-function", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'objective-functions']

  def _get_objective_function(self):
    """
    Getter method for objective_function, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function (list)

    YANG Description: Each entry contains an objective function instance.
    """
    return self.__objective_function
      
  def _set_objective_function(self, v, load=False):
    """
    Setter method for objective_function, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions/objective_function (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_objective_function is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_objective_function() directly.

    YANG Description: Each entry contains an objective function instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_objective_function_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function, yang_name="objective-function", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """objective_function must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_objective_function_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function, yang_name="objective-function", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)""",
        })

    self.__objective_function = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_objective_function(self):
    self.__objective_function = YANGDynClass(base=YANGListType("type name",yc_objective_function_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions_objective_function, yang_name="objective-function", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=True)

  objective_function = __builtin__.property(_get_objective_function, _set_objective_function)


  _pyangbind_elements = OrderedDict([('objective_function', objective_function), ])


class yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RPL neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_address','__last_update','__rank','__cost',)

  _yang_name = 'neighbor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__rank = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'neighbors', u'neighbor']

  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/ipv6_address (inet:ipv6-address)

    YANG Description: IP address that a RPL neighbor is using as its
source address.
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IP address that a RPL neighbor is using as its
source address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)


  def _get_last_update(self):
    """
    Getter method for last_update, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/last_update (yang:date-and-time)

    YANG Description: The time when the most recent RPL update was
received from this neighbor.
    """
    return self.__last_update
      
  def _set_last_update(self, v, load=False):
    """
    Setter method for last_update, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/last_update (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_update is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_update() directly.

    YANG Description: The time when the most recent RPL update was
received from this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_update must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_update = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_update(self):
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='yang:date-and-time', is_config=False)


  def _get_rank(self):
    """
    Getter method for rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/rank (uint16)

    YANG Description: The current rank of the node in the DODAG.
    """
    return self.__rank
      
  def _set_rank(self, v, load=False):
    """
    Setter method for rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/rank (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rank is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rank() directly.

    YANG Description: The current rank of the node in the DODAG.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rank must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__rank = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rank(self):
    self.__rank = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/cost (uint16)

    YANG Description: The cost set up by the implemented metric.
It could be distance to sink node, ETX, hops count, etc.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor/cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: The cost set up by the implemented metric.
It could be distance to sink node, ETX, hops count, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)

  ipv6_address = __builtin__.property(_get_ipv6_address)
  last_update = __builtin__.property(_get_last_update)
  rank = __builtin__.property(_get_rank)
  cost = __builtin__.property(_get_cost)


  _pyangbind_elements = OrderedDict([('ipv6_address', ipv6_address), ('last_update', last_update), ('rank', rank), ('cost', cost), ])


class yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 neighbor information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("ipv6_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor (list)

    YANG Description: A RPL neighbor.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: A RPL neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv6_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv6_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ipv6_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_node_preferred_parent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents_node_preferred_parent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/node-preferred-parents/node-preferred-parent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A node preferred parent information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_address','__parent_ipv6_address','__parent_rank','__parent_cost','__rank','__cost',)

  _yang_name = 'node-preferred-parent'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    self.__rank = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__parent_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="parent-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    self.__parent_cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__parent_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'node-preferred-parents', u'node-preferred-parent']

  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/ipv6_address (inet:ipv6-address)

    YANG Description: IP address that the current node is using as its
source address.
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IP address that the current node is using as its
source address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)


  def _get_parent_ipv6_address(self):
    """
    Getter method for parent_ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_ipv6_address (inet:ipv6-address)

    YANG Description: IP address that the preferred parent of the current node
is using as its source address.
    """
    return self.__parent_ipv6_address
      
  def _set_parent_ipv6_address(self, v, load=False):
    """
    Setter method for parent_ipv6_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_ipv6_address() directly.

    YANG Description: IP address that the preferred parent of the current node
is using as its source address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="parent-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="parent-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)""",
        })

    self.__parent_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_ipv6_address(self):
    self.__parent_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="parent-ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)


  def _get_parent_rank(self):
    """
    Getter method for parent_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_rank (uint16)

    YANG Description: The node preferred parent rank. It could be 0 if
the current node rank is 1.
    """
    return self.__parent_rank
      
  def _set_parent_rank(self, v, load=False):
    """
    Setter method for parent_rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_rank (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_rank is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_rank() directly.

    YANG Description: The node preferred parent rank. It could be 0 if
the current node rank is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_rank must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__parent_rank = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_rank(self):
    self.__parent_rank = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)


  def _get_parent_cost(self):
    """
    Getter method for parent_cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_cost (uint16)

    YANG Description: The cost set up by the implemented metric at the preferred
parent node.
It could be distance to sink node, ETX, hops count, etc.
    """
    return self.__parent_cost
      
  def _set_parent_cost(self, v, load=False):
    """
    Setter method for parent_cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/parent_cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_cost() directly.

    YANG Description: The cost set up by the implemented metric at the preferred
parent node.
It could be distance to sink node, ETX, hops count, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__parent_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_cost(self):
    self.__parent_cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="parent-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)


  def _get_rank(self):
    """
    Getter method for rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/rank (uint16)

    YANG Description: The current rank of the node in the DODAG.
    """
    return self.__rank
      
  def _set_rank(self, v, load=False):
    """
    Setter method for rank, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/rank (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rank is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rank() directly.

    YANG Description: The current rank of the node in the DODAG.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rank must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__rank = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rank(self):
    self.__rank = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'1..max']}), is_leaf=True, yang_name="rank", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/cost (uint16)

    YANG Description: The cost set up by the implemented metric.
It could be distance to sink node, ETX, hops count, etc.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent/cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: The cost set up by the implemented metric.
It could be distance to sink node, ETX, hops count, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)

  ipv6_address = __builtin__.property(_get_ipv6_address)
  parent_ipv6_address = __builtin__.property(_get_parent_ipv6_address)
  parent_rank = __builtin__.property(_get_parent_rank)
  parent_cost = __builtin__.property(_get_parent_cost)
  rank = __builtin__.property(_get_rank)
  cost = __builtin__.property(_get_cost)


  _pyangbind_elements = OrderedDict([('ipv6_address', ipv6_address), ('parent_ipv6_address', parent_ipv6_address), ('parent_rank', parent_rank), ('parent_cost', parent_cost), ('rank', rank), ('cost', cost), ])


class yc_node_preferred_parents_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/node-preferred-parents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sub-dodag nodes preferred parents information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_preferred_parent',)

  _yang_name = 'node-preferred-parents'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_preferred_parent = YANGDynClass(base=YANGListType("ipv6_address",yc_node_preferred_parent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents_node_preferred_parent, yang_name="node-preferred-parent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="node-preferred-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'node-preferred-parents']

  def _get_node_preferred_parent(self):
    """
    Getter method for node_preferred_parent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent (list)

    YANG Description: A node preferred parent information.
    """
    return self.__node_preferred_parent
      
  def _set_node_preferred_parent(self, v, load=False):
    """
    Setter method for node_preferred_parent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents/node_preferred_parent (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_preferred_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_preferred_parent() directly.

    YANG Description: A node preferred parent information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv6_address",yc_node_preferred_parent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents_node_preferred_parent, yang_name="node-preferred-parent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="node-preferred-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_preferred_parent must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv6_address",yc_node_preferred_parent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents_node_preferred_parent, yang_name="node-preferred-parent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="node-preferred-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)""",
        })

    self.__node_preferred_parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_preferred_parent(self):
    self.__node_preferred_parent = YANGDynClass(base=YANGListType("ipv6_address",yc_node_preferred_parent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents_node_preferred_parent, yang_name="node-preferred-parent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="node-preferred-parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='list', is_config=False)

  node_preferred_parent = __builtin__.property(_get_node_preferred_parent)


  _pyangbind_elements = OrderedDict([('node_preferred_parent', node_preferred_parent), ])


class yc_dodag_version_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology_dodag_version(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/dodag-topology/dodag-version. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: DODAG uniqueness identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rpl_instance_id','__dodag_id','__dodag_version_number',)

  _yang_name = 'dodag-version'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dodag_version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dodag-version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)
    self.__rpl_instance_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="rpl-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)
    self.__dodag_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dodag-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'dodag-topology', u'dodag-version']

  def _get_rpl_instance_id(self):
    """
    Getter method for rpl_instance_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/rpl_instance_id (uint8)
    """
    return self.__rpl_instance_id
      
  def _set_rpl_instance_id(self, v, load=False):
    """
    Setter method for rpl_instance_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/rpl_instance_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rpl_instance_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rpl_instance_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="rpl-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rpl_instance_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="rpl-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)""",
        })

    self.__rpl_instance_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rpl_instance_id(self):
    self.__rpl_instance_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="rpl-instance-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)


  def _get_dodag_id(self):
    """
    Getter method for dodag_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/dodag_id (inet:ipv6-address)
    """
    return self.__dodag_id
      
  def _set_dodag_id(self, v, load=False):
    """
    Setter method for dodag_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/dodag_id (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dodag_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dodag_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dodag-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dodag_id must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dodag-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)""",
        })

    self.__dodag_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dodag_id(self):
    self.__dodag_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dodag-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='inet:ipv6-address', is_config=False)


  def _get_dodag_version_number(self):
    """
    Getter method for dodag_version_number, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/dodag_version_number (uint8)

    YANG Description: A DODAG is sometimes reconstructed from the DODAG root,
by incrementing the DODAGVersionNumber.
    """
    return self.__dodag_version_number
      
  def _set_dodag_version_number(self, v, load=False):
    """
    Setter method for dodag_version_number, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version/dodag_version_number (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dodag_version_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dodag_version_number() directly.

    YANG Description: A DODAG is sometimes reconstructed from the DODAG root,
by incrementing the DODAGVersionNumber.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dodag-version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dodag_version_number must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dodag-version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)""",
        })

    self.__dodag_version_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dodag_version_number(self):
    self.__dodag_version_number = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dodag-version-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint8', is_config=False)

  rpl_instance_id = __builtin__.property(_get_rpl_instance_id)
  dodag_id = __builtin__.property(_get_dodag_id)
  dodag_version_number = __builtin__.property(_get_dodag_version_number)


  _pyangbind_elements = OrderedDict([('rpl_instance_id', rpl_instance_id), ('dodag_id', dodag_id), ('dodag_version_number', dodag_version_number), ])


class yc_dodag_topology_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing/dodag-topology. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: DODAG topology construction and mantaninment information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__objective_function','__num_of_nodes','__dodag_version',)

  _yang_name = 'dodag-topology'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dodag_version = YANGDynClass(base=yc_dodag_version_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology_dodag_version, is_container='container', yang_name="dodag-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    self.__num_of_nodes = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-of-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    self.__objective_function = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='rpl:of-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing', u'dodag-topology']

  def _get_objective_function(self):
    """
    Getter method for objective_function, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/objective_function (rpl:of-ref)

    YANG Description: The OF used in the current RPL instance.
All DODAGs in the same RPL Instance use the same OF.
RFC6550 section 3.1.2.
    """
    return self.__objective_function
      
  def _set_objective_function(self, v, load=False):
    """
    Setter method for objective_function, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/objective_function (rpl:of-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_objective_function is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_objective_function() directly.

    YANG Description: The OF used in the current RPL instance.
All DODAGs in the same RPL Instance use the same OF.
RFC6550 section 3.1.2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='rpl:of-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """objective_function must be of a type compatible with rpl:of-ref""",
          'defined-type': "rpl:of-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='rpl:of-ref', is_config=False)""",
        })

    self.__objective_function = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_objective_function(self):
    self.__objective_function = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="objective-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='rpl:of-ref', is_config=False)


  def _get_num_of_nodes(self):
    """
    Getter method for num_of_nodes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/num_of_nodes (uint16)

    YANG Description: Number of nodes in the DODAG, including sink node.
    """
    return self.__num_of_nodes
      
  def _set_num_of_nodes(self, v, load=False):
    """
    Setter method for num_of_nodes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/num_of_nodes (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_of_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_of_nodes() directly.

    YANG Description: Number of nodes in the DODAG, including sink node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-of-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_of_nodes must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-of-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)""",
        })

    self.__num_of_nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_of_nodes(self):
    self.__num_of_nodes = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-of-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='uint16', is_config=False)


  def _get_dodag_version(self):
    """
    Getter method for dodag_version, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version (container)

    YANG Description: DODAG uniqueness identifier.
    """
    return self.__dodag_version
      
  def _set_dodag_version(self, v, load=False):
    """
    Setter method for dodag_version, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology/dodag_version (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dodag_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dodag_version() directly.

    YANG Description: DODAG uniqueness identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dodag_version_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology_dodag_version, is_container='container', yang_name="dodag-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dodag_version must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dodag_version_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology_dodag_version, is_container='container', yang_name="dodag-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)""",
        })

    self.__dodag_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dodag_version(self):
    self.__dodag_version = YANGDynClass(base=yc_dodag_version_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology_dodag_version, is_container='container', yang_name="dodag-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)

  objective_function = __builtin__.property(_get_objective_function)
  num_of_nodes = __builtin__.property(_get_num_of_nodes)
  dodag_version = __builtin__.property(_get_dodag_version)


  _pyangbind_elements = OrderedDict([('objective_function', objective_function), ('num_of_nodes', num_of_nodes), ('dodag_version', dodag_version), ])


class yc_upward_routing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing/upward-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Neighbors, preferred parents, and dodag construction information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbors','__node_preferred_parents','__dodag_topology',)

  _yang_name = 'upward-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    self.__dodag_topology = YANGDynClass(base=yc_dodag_topology_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology, is_container='container', yang_name="dodag-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    self.__node_preferred_parents = YANGDynClass(base=yc_node_preferred_parents_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents, is_container='container', yang_name="node-preferred-parents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing', u'upward-routing']

  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors (container)

    YANG Description: IPv6 neighbor information.
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: IPv6 neighbor information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)


  def _get_node_preferred_parents(self):
    """
    Getter method for node_preferred_parents, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents (container)

    YANG Description: Sub-dodag nodes preferred parents information.
    """
    return self.__node_preferred_parents
      
  def _set_node_preferred_parents(self, v, load=False):
    """
    Setter method for node_preferred_parents, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/node_preferred_parents (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_preferred_parents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_preferred_parents() directly.

    YANG Description: Sub-dodag nodes preferred parents information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_node_preferred_parents_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents, is_container='container', yang_name="node-preferred-parents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_preferred_parents must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_node_preferred_parents_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents, is_container='container', yang_name="node-preferred-parents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)""",
        })

    self.__node_preferred_parents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_preferred_parents(self):
    self.__node_preferred_parents = YANGDynClass(base=yc_node_preferred_parents_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_node_preferred_parents, is_container='container', yang_name="node-preferred-parents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)


  def _get_dodag_topology(self):
    """
    Getter method for dodag_topology, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology (container)

    YANG Description: DODAG topology construction and mantaninment information.
    """
    return self.__dodag_topology
      
  def _set_dodag_topology(self, v, load=False):
    """
    Setter method for dodag_topology, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing/dodag_topology (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dodag_topology is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dodag_topology() directly.

    YANG Description: DODAG topology construction and mantaninment information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dodag_topology_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology, is_container='container', yang_name="dodag-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dodag_topology must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dodag_topology_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology, is_container='container', yang_name="dodag-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)""",
        })

    self.__dodag_topology = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dodag_topology(self):
    self.__dodag_topology = YANGDynClass(base=yc_dodag_topology_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing_dodag_topology, is_container='container', yang_name="dodag-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)

  neighbors = __builtin__.property(_get_neighbors)
  node_preferred_parents = __builtin__.property(_get_node_preferred_parents)
  dodag_topology = __builtin__.property(_get_dodag_topology)


  _pyangbind_elements = OrderedDict([('neighbors', neighbors), ('node_preferred_parents', node_preferred_parents), ('dodag_topology', dodag_topology), ])


class yc_routing_addresing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl/routing-addresing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 addressing and RPL routing information
  """
  __slots__ = ('_path_helper', '_extmethods', '__upward_routing',)

  _yang_name = 'routing-addresing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__upward_routing = YANGDynClass(base=yc_upward_routing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing, is_container='container', yang_name="upward-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl', u'routing-addresing']

  def _get_upward_routing(self):
    """
    Getter method for upward_routing, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing (container)

    YANG Description: Neighbors, preferred parents, and dodag construction information.
    """
    return self.__upward_routing
      
  def _set_upward_routing(self, v, load=False):
    """
    Setter method for upward_routing, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing/upward_routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upward_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upward_routing() directly.

    YANG Description: Neighbors, preferred parents, and dodag construction information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_upward_routing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing, is_container='container', yang_name="upward-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upward_routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_upward_routing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing, is_container='container', yang_name="upward-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)""",
        })

    self.__upward_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upward_routing(self):
    self.__upward_routing = YANGDynClass(base=yc_upward_routing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing_upward_routing, is_container='container', yang_name="upward-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=False)

  upward_routing = __builtin__.property(_get_upward_routing)


  _pyangbind_elements = OrderedDict([('upward_routing', upward_routing), ])


class yc_rpl_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/rpl. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RPL data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trickle','__interfaces','__objective_functions','__routing_addresing',)

  _yang_name = 'rpl'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_addresing = YANGDynClass(base=yc_routing_addresing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing, is_container='container', yang_name="routing-addresing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    self.__trickle = YANGDynClass(base=yc_trickle_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_trickle, is_container='container', yang_name="trickle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    self.__objective_functions = YANGDynClass(base=yc_objective_functions_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions, is_container='container', yang_name="objective-functions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol', u'rpl']

  def _get_trickle(self):
    """
    Getter method for trickle, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle (container)

    YANG Description: Trickle timer variables and parameters.
    """
    return self.__trickle
      
  def _set_trickle(self, v, load=False):
    """
    Setter method for trickle, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/trickle (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trickle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trickle() directly.

    YANG Description: Trickle timer variables and parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_trickle_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_trickle, is_container='container', yang_name="trickle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trickle must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_trickle_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_trickle, is_container='container', yang_name="trickle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)""",
        })

    self.__trickle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trickle(self):
    self.__trickle = YANGDynClass(base=yc_trickle_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_trickle, is_container='container', yang_name="trickle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces (container)

    YANG Description: Containing a list of RPL interfaces.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Containing a list of RPL interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)


  def _get_objective_functions(self):
    """
    Getter method for objective_functions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions (container)

    YANG Description: Support for objective functions
    """
    return self.__objective_functions
      
  def _set_objective_functions(self, v, load=False):
    """
    Setter method for objective_functions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/objective_functions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_objective_functions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_objective_functions() directly.

    YANG Description: Support for objective functions
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_objective_functions_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions, is_container='container', yang_name="objective-functions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """objective_functions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_objective_functions_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions, is_container='container', yang_name="objective-functions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)""",
        })

    self.__objective_functions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_objective_functions(self):
    self.__objective_functions = YANGDynClass(base=yc_objective_functions_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_objective_functions, is_container='container', yang_name="objective-functions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)


  def _get_routing_addresing(self):
    """
    Getter method for routing_addresing, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing (container)

    YANG Description: IPv6 addressing and RPL routing information
    """
    return self.__routing_addresing
      
  def _set_routing_addresing(self, v, load=False):
    """
    Setter method for routing_addresing, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl/routing_addresing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_addresing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_addresing() directly.

    YANG Description: IPv6 addressing and RPL routing information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_addresing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing, is_container='container', yang_name="routing-addresing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_addresing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_addresing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing, is_container='container', yang_name="routing-addresing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)""",
        })

    self.__routing_addresing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_addresing(self):
    self.__routing_addresing = YANGDynClass(base=yc_routing_addresing_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl_routing_addresing, is_container='container', yang_name="routing-addresing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)

  trickle = __builtin__.property(_get_trickle, _set_trickle)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  objective_functions = __builtin__.property(_get_objective_functions, _set_objective_functions)
  routing_addresing = __builtin__.property(_get_routing_addresing, _set_routing_addresing)


  _pyangbind_elements = OrderedDict([('trickle', trickle), ('interfaces', interfaces), ('objective_functions', objective_functions), ('routing_addresing', routing_addresing), ])


class yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains a control-plane protocol instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description','__rpl',)

  _yang_name = 'control-plane-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rpl = YANGDynClass(base=yc_rpl_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl, is_container='container', yang_name="rpl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols', u'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_rpl(self):
    """
    Getter method for rpl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl (container)

    YANG Description: RPL data.
    """
    return self.__rpl
      
  def _set_rpl(self, v, load=False):
    """
    Setter method for rpl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/rpl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rpl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rpl() directly.

    YANG Description: RPL data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rpl_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl, is_container='container', yang_name="rpl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rpl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rpl_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl, is_container='container', yang_name="rpl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)""",
        })

    self.__rpl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rpl(self):
    self.__rpl = YANGDynClass(base=yc_rpl_ietf_routing__routing_control_plane_protocols_control_plane_protocol_rpl, is_container='container', yang_name="rpl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:uis-rpl', defining_module='uis-rpl', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  rpl = __builtin__.property(_get_rpl, _set_rpl)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ('rpl', rpl), ])


class yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for control-plane protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol, _set_control_plane_protocol)


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list)

  __choices__ = {u'next-hop-options': {u'simple-next-hop': [u'outgoing_interface'], u'next-hop-list': [u'next_hop_list'], u'special-next-hop': [u'special_next_hop']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes', u'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop)
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib', u'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route)


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_rib_ietf_routing__routing_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__description',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/ribs/rib/name (string)

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/ribs/rib/description (string)

    YANG Description: Textual description of the RIB.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/ribs/rib/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes, _set_routes)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('description', description), ])


class yc_ribs_ietf_routing__routing_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/ribs/rib (list)

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  rib = __builtin__.property(_get_rib, _set_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_ietf_routing__routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)

    YANG Description: Support for control-plane protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Support for control-plane protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing/ribs (container)

    YANG Description: Support for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Support for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols, _set_control_plane_protocols)
  ribs = __builtin__.property(_get_ribs, _set_ribs)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class yc_interfaces_ietf_routing__routing_state_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-state-ref""",
          'defined-type': "if:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name',)

  _yang_name = 'control-plane-protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'control-plane-protocols', u'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'routing-protocol': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ])


class yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the list of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol)


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop', u'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=(u'next-hop-options', u'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop)

  __choices__ = {u'next-hop-options': {u'next-hop-list': [u'next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route', u'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=(u'next-hop-options', u'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'receive': {}, u'unreachable': {}, u'blackhole': {}, u'prohibit': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=(u'next-hop-options', u'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=(u'next-hop-options', u'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list)

  __choices__ = {u'next-hop-options': {u'simple-next-hop': [u'outgoing_interface'], u'next-hop-list': [u'next_hop_list'], u'special-next-hop': [u'special_next_hop']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes', u'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'direct': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:static': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rpl:rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}, u'rpl': {u'@namespace': u'urn:ietf:params:xml:ns:yang:uis-rpl', u'@module': u'uis-rpl'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop)
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_state_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib', u'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route)


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_rib_ietf_routing__routing_state_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes',)

  _yang_name = 'rib'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs', u'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)

    YANG Description: The name of the RIB.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'rt:ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'rt:ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv4': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}, u'ipv6': {u'@namespace': u'urn:ietf:params:xml:ns:yang:ietf-routing', u'@module': u'ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  address_family = __builtin__.property(_get_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ])


class yc_ribs_ietf_routing__routing_state_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state', u'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  rib = __builtin__.property(_get_rib)


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_state_ietf_routing__routing_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing-state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'routing-state']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)

    YANG Description: Container for the list of routing protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Container for the list of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing_state/ribs (container)

    YANG Description: Container for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing_state/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Container for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  interfaces = __builtin__.property(_get_interfaces)
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols)
  ribs = __builtin__.property(_get_ribs)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class ietf_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /ietf-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines essential components for the management
of a routing subsystem. The model fully conforms to the Network
Management Datastore Architecture (NMDA).

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing','__routing_state',)

  _yang_name = 'ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /routing (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /routing_state (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /routing_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  routing = __builtin__.property(_get_routing, _set_routing)
  routing_state = __builtin__.property(_get_routing_state, _set_routing_state)


  _pyangbind_elements = OrderedDict([('routing', routing), ('routing_state', routing_state), ])


